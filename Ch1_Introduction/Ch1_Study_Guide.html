<!DocType=html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="../style/mystyle.css">
	</head>
	<body>
		<h1>Ch1 Introduction</h1>
		<nav class="navbar">
			<a href="../MAIN_index.html">Home</a>
			<a href="../Ch2_Operators/Ch2_Study_Guide.html">Ch3 Java Operators &rightarrow;</a>
		</nav>
		<h2>The Java Environment</h2>
		<ul>
			<li>
				The Java Development Kit (<b>JDK</b>) contains the compiler (<code>javac</code>)
				 and the java runtime executable (<code>java</code>)
			</li>
			<li>Java <a href="#classstructureheader">Class files</a> run on the Java Runtime Environment (JVM).  
				The JVM can be installed on any machine, allowing the class files to run on any machine. 
			</li>
		<li>
			The versions of your java and java compiler can be checked with the following at the command line:
			<pre><code class="codeblock">
javac -version
java -version
			</code></pre>
		</li>
		</ul>
		<h2 id="classstructureheader">Class Structure</h2>
		<ul>
			<li> the Java <b>Class</b> 
			<ul>
				<li>Composed of <i>fields</i> and <i>methods</i>
				which together are called the <i>members</i> of the class.
				</li>
				<li>Contained in source files ending in <code>.java</code>
					<ul>
						<li>
							Each file can contain only <i>one</i> <code>public</code> class,
							but may contain more class definitions as long as they are <b>package-private</b>
							(no <code>public</code> or other <i>access-modifier</i> in front of 
							the <code>class</code> keyword)
						</li>
						<li>The filename must match the class name (including case) and have the
							<code>.java</code> extension.
						</li>
						<li> If the Java class is an entry point for the program, 
							it must contain a valid <code><a href="#mainmethodheader">main()</a></code> method.
						</li>
					</ul>
				</li>
				<li><h3>Ordering of Class parts in a .java file:</h3>
					<ol>
						<li>Package declaration (<code">package abc;</code>  not required)</li>
						<li>Import statements (<code>import java.util.*;</code>  not required)</li>
						<li>Top-level type declaration (<code> public Class MyClass{}</code>  required)</li>
						<li>Field declarations (<code>int value1;</code>  not required)</li>
						<li>Method declarations (<code>void method1(){}</code>  not required)</li>
					</ol>
				</li>
			</ul>
			</li>
		</ul>
		<h2 id="mainmethodheader">The <code>main()</code> Method</h2>
		<ul>
			<li>Java programs begin execution at the main method.
			</li>
			<li>Example main method:
				<pre><code class="codeblock">
public class MainClass {
	<b>public static final void main(final String[] args)</b> {
		System.out.println("Hello World!")
		if (args!=null) {
			System.out.println(java.util.Arrays.toString(args));
		}
	}
}
				</code></pre>
			<ul>
				<li>Note that the <code>final</code> keyword is an optional-modifier that is not required, but is good practice.
				</li>
				<li>This program can be called with the following command-line input:
					<pre><code class="codeblock">
javac MainClass.java
java MainClass Arg1 Arg2 Arg3 ...
					</code></pre>
				</li>
			</ul>
			</li>
		</ul>
		<h2>
			Package Declarations and Imports		
		</h2>
		<ul>
			<li>Java classes are grouped logically in <b>packages</b></li>
			<li>The <code>import</code> statement tells the compiler where classes are located</li>
			<li>Example: <code>import java.util.Random;</code></li>
			<li><i>Wildcards</i> can be used to import all the classes located in a package
				<ul>
					<li>
						Example: <code>import java.util.*;</code>
					</li>
				</ul>
			</li>
			<li>The <code>java.lang</code> package is automatically imported</li>
			<li>Classes located in the same package do not need import statements to eachother</li>
			<li><h3>Naming Conflicts</h3>
				<ul>
					<li>Packages allow you to use class names that do not need to be unique by using the <i>full qualified class name</i></li>
					<pre><code class="codeblock">
public class Conflicts {
	java.util.Date date;
	java.sql.Date sqlData;
}		
					</code></pre>					
				</ul>
			</li>
			<li><i>Wildcards</i> can be used to compile all the classes in a package:
				<pre><code class="codeblock">
javac packagea/*.java packageb/*.java packagec/*.java
				</code></pre>
			</li>
			<li>
				The java compiler can compile to another directory using the <code>-d</code> (directory) option.  
				Then the <code>-cp</code> (classpath) option can be used to run the program with the new class directory. 
				<pre><code class="codeblock">
javac -d &lt;classesFolderPath&gt; com.packagea/*.java com.packageb/*.java
java -cp &lt;classesFolderPath&gt; com.packagea.MainClass
				</code></pre>
			</li>
		</ul>
		<h2>JAR Files</h2>
		<ul>
			<li><i>Java archive</i> files (<b>JAR</b>) is a compressed file (similar to a zip file) of java class files, and possible other types of files.</li>
			<li>Creating a jar file: <code">jar -cvf &lt;newFileName.jar&gt; -C &lt;classDirectory&gt;</code>
				<ul>
					<li><code>-cvf</code> is short hand for the create, verbose, and filename options</li>
					<li><code>-C</code>(<i>capitalized</i> C) is the directory option specifying the directory for the class files to be used to create the JAR file. 
						This option is not needed if the current directory from which the command is the root directory for your files. </li>
				</ul>
			</li>
			<li>Compiling with JAR files and/or multiple class path directories:
				<pre><code class="codeblock">
java -cp ".;C:\path1\myJar.jar;C:\path2\myJar2.jar;C:\path3\directoryWithJars\*" myMainPackage.MainClass
				</code></pre>
				<ul>
					<li>On windows, directories are separated with the semi-colon (;), while other os's use the colon (:) to separate directories</li>
					<li>The period (.) specifies the current directory should be included in the class path</li>
				</ul>
			</li>
		</ul>
		<h3 id="java-objects-section">Java Objects</h3>
		<ul>
			<li>Constructors
				<ul>
					<li><a href="../Ch6_Class_Design/Ch6_Class_Design.html#constructor-section">Constructors</a> 
						are called to create a new instance of a class</li>
					<li>Requirements:
						<ol>
							<li>The construtor name must match the name of the class</li>
							<li>There is no return type</li>
						</ol>
					</li>
				</ul>
			</li>
			<li>Class Instance Initialization Order
				<ol>
					<li>Fields and instance initializer blocks run in order they appear</li>
					<li>Constructor runs after all fields and instance initializer blocks have run</li>
				</ol>
				<pre><code class="codeblock">
public class InitializationExampleClass {
	private String name = "Bill"; // field initialization runs first
	{ System.out.print(name + ", "); // instance initializer block runs 2nd
		name = "Molly";
		System.out.print(name + ", ");
	}
	public InitializationExampleClass() { // constructor runs 3rd
		name = "Sarah";
		System.out.print(name);
	}
					
	public static void main(final String args[]) {
		final InitializationExampleClass ex = new InitializationExampleClass();
		// code output: Bill, Molly, Sarah
	}
}
				</code></pre>
			</li>
		</ul>
		<h2 id="java-data-types-section">Java Data Types</h2>
		Java applications contain two different types of data: primitive types and references types
		<ol>
			<li>Primitive Types
				<ul>
					<li> Java contains 8 <i>primitive types</i>, which are used to build all of the more complex Java objects</li>
					<li> Primitive data types are not objects, they are a value in memory</li>
					<li> Integer values can be written in different bases:
						<ul>
							<li>Octal uses 0 as the prefix: <code>017</code></li>
							<li>Hexadecimal uses 0x or 0X as the prefix: <code>0xFD1A</code></li>
							<li>Binary uses 0b or 0B as the prefix: <code>0b10110101</code></li>
						</ul>
					</li>
					<li>Literal values may contains underscores to make them easier to read, as long as they don't start or stop with 
					the underscore, and the underscore is not located directly before or afer a decimal (.): <code>final double val = 1_000_000.032_981</code></li>
				</ul>
				<p class="tableheader">Primitive Types</p>				
				<div class="tablecontainer"><table id="primitive-types-table">
					<tr>
						<th>Keyword</th><th>Type</th><th>Min val</th><th>Max val</th>
						<th>Default val</th><th>Example</th> <th>Wrapper class</th>
					</tr>
					<tr>
						<td><code>boolean</code></td> <td><code>true</code> or <code>false</code></td>
						<td>n/a</td> <td>n/a</td> <td><code>false</code></td> <td><code>true</code></td> <td><code>Boolean</code></td>
					</tr>
					<tr>
						<td><code>byte</code></td> <td>8-bit integer</td>
						<td><code>-128 (-2<sup>-7</sup>)</code></td> <td><code>127 (2<sup>7</sup>-1)</code></td>
						<td><code>0</code></td> <td><code>87</code></td> <td><code>Byte</code></td>
					</tr>
					<tr>
						<td><code>short</code></td> <td>16-bit integer</td>
						<td><code>-32,768 (-2<sup>-15</sup>)</code></td> <td><code>32,767 (2<sup>15</sup>-1)</code></td>
						<td><code>0</code></td> <td><code>87</code></td> <td><code>Short</code></td>
					</tr>
					<tr>
						<td><code>int</code></td> <td>32-bit integer</td>
						<td><code>-2,147483,648 (-2<sup>-31</sup>)</code></td> <td><code>2,147,483,647 (2<sup>31</sup>-1)</code></td>
						<td><code>0</code></td> <td><code>87</code></td> <td><code>Integer</code></td>
					</tr>
					<tr>
						<td><code>long</code></td> <td>64-bit integer</td>
						<td><code>-2<sup>-63</sup></code></td> <td><code>2<sup>63</sup>-1</code></td>
						<td><code>0L</code></td> <td><code>87L</code></td> <td><code>Long</code></td>
					</tr>
					<tr>
						<td><code>float</code></td> <td>32-bit floating point value</td>
						<td>n/a</td> <td>n/a</td>
						<td><code>0.0f</code></td> <td><code>123.45f</code></td>
						<td><code>Float</code></td>
					</tr>
					<tr>
						<td><code>double</code></td> <td>64-bit floating point value</td>
						<td>n/a</td> <td>n/a</td>
						<td><code>0.0</code></td> <td><code>123.456</code></td> <td><code>Double</code></td>
					</tr>
					<tr>
						<td><code>char</code></td> <td>16-bit unicode value</td>
						<td><code>0</code></td> <td><code>65,535</code></td>
						<td><code>\u0000</code></td> <td><code>'a'</code></td> <td><code>Character</code></td>
					</tr>
				</table></div>
			</li>
			<li>Reference Types
				<ul>
					<li><i>Reference types</i> refer to an object (instance of a class)</li>
					<li>A <i>reference</i> points to an object's address in memory
						<ul>
							<li>Can be assigned to another object of the same compatible type (if not <code>final</code>)</li>
							<li>Can be assigned to a new object using the <code>new</code> keyword</li>
						</ul>
					</li>
					<li>Reference types can be used to call methods that act on the object (primitive types cannot)</li>
					<li>
						An object and a reference are two separate entities.  The reference is a variable that has a name and can be used to access an object's data.
						The reference can also be assigned to reference another object (if not <code>final</code>), 
						can reference another reference's object, passed to a method, or returned from a method.
						The objects sits on the heap, does not have a name, and can only be accessed through a reference.
					</li>
					<li>All the primitive types have wrapper classes with useful functions, and can also be used to store a
					<code>null</code>value (primitive types cannot), as depicted in the last column of <a href="#primitive-types-table">the table above</a>. 
						Wrapper types can be unboxed by the compiler and substituted for the primitive values.
					</li>
					<li>Text blocks
						<ul>
							<li>Allows for multiline strings</li>
							<li>Starts and ends with three double quotes (""")</li>
							<li id="incidental-white-space"><i>Incidental</i> white space:  whitespace that may be used to make code easier to read but not actually included, to the left of the left-most
							non-white-space character</li>
							<li>Including a single backslash character at the end of a line (<code>\</code>)
							omits the newline character and concatenates that line and the following line</li>
							<li><i>Essential</i> white space:  white space included as part of the <code>String</code></li>
							<pre><code class="codeblock">
final String pyramid = """ // 1 character of incidental white space on each line
   *      // 2 two essential white space characters
  * *     // 1 essentail white space characters							
 * * *    // no essential white space characters
"""      // as new line character is included at the end of this string 
         // since the closing triple quotations is on a new line							
								</code></pre>
						</ul>
					</li>
				</ul>
			</li>
		</ol>
		<h2>Declaring Variables</h2>
		<ul>
			<li>A <i>variable</i> is a piece of memory that stores data</li>
			<li id="identifier-rules-section">An <i>identifier</i> is the name of a variable, class, interface, or package.  They have a set of 4 rules that must be followed:
				<ol>
					<li>Identifiers must begin with a letter, a currency symbol ( <code>$</code> ), or an underscore ( <code>_</code> )</li>
					<li>May include numbers but <i>cannot</i> start with them</li>
					<li>A single underscore does not qualify as an identifier (but more than one does!)</li>
					<li>Cannot constist of a Java <i>reserved word</i> (<code>class, for, void, static,</code> etc.)</li>
				</ol>
			</li>
			<li id="multiple-variable-declaration"><b>Multiple Variable Declaration:</b>
				<ul>
					<li>Many variables may be declares and initialized in the same statement</li>
					<li>Any or all of those values can be initialized inline</li>
					<li>There is only 1 type definition, located at the beginning of the statement, and each variable is comma-separated.  This
					means that all variables declared in a single statement must be the same type and share the same declaration.</li>
					<pre><code class="codeblock">
boolean b1, b2;            // legal, 2 variables declared
String s1 = "one", s2;     // legal, 2 variables declared, 1 initialized inline 
int i1; int i2;            // legal, but this is just two java statements, not a multiple-declaration
double d1, double d2;      // illegal, as there are 2 type declarations.
int i3; i4;                // illegal because the variable names are not comma separated.
						</code></pre>
				    <li>Mutliple variables of the same type can also be initialized to 
						the <a href="../Ch2_Operators/Ch2_Study_Guide.html#assignment-op">same value</a>.
					<pre><code class="codeblock">
long x, y, z;
x = y = z = 50L; // all 3 variables equal to 50
					</code></pre>
					</li>
				</ul>
			</li>
		</ul>
		<h2>Initializing Variables</h2>
		<ul>
			<li>A <i>local variable</i> is defined withint a constructor, method, initializer block, or other types of code blocks</li>
			<li>The <b><code>final</code></b> keyword is used to declare a local primitive variable as a constant.  
				The optional <code>final</code> <i>modifier</i> can also be used on
			reference variables, but this only makes which object the reference is pointing to constant, not the underlying object data itself.</li>
			<li>Local varibles are not valid until initalized:
				<pre><code class="codeblock">
final int y = 10;
int x;
final int reply = x + y; // does not compile, as x has not been initialized					
					</code></pre>
			</li>
			<li>Variables passed to a constructor or method are known as <i>constructor parameters</i>, or <i>method parameters</i>, respectively. 
			The caller is responsible for initializing these variables before passing them to the constructor or method.</li>
			<li>A field variable defined within a class definition, also known an <i>instance variable</i>, is a value defined
			for a specific instance of an class object.</li>
			<li>A <i>class variable</i> is defined on the class variable and shared among all the instances of the class, and is designed using
			the <code>static</code> keyword.  Instance variables <i>do not</i> require explicit initialization, as they are automatically initialized
			to their default values.</li>
			<li><b>Local variable type inference</b>
				<ul>
					<li>The <code>var</code> keyword can be used instead of an explicit type declaration for local variables only.</li>
					<li>The local variable must be declared and immediately intialized inline in the same statement: 
						<code>final var value = 10L;</code></li>
					<li>The compiler only looks at the variable declaration statement to infer its type, so the variable cannot change type at a later point.</li>
					<li><code>var</code> <i>cannot</i> be used with multiline inference because each variable declared with <code>var</code> must
						be immediately initialized inline.</li>
					<li>Note that <code>var</code> <i>is not</i> a reserved Java keyword:
					<pre><code class="codeblock">
package var;

public class Var {   // this is all legal code

	public void var() {
		final var var = "var";				
	}
	public void Var() {
		final Var var = new Var();
	}
}
						</code></pre>
					</li>
				</ul>
			</li>
		</ul>
		<h2>Managing Variable Scope</h2>
		<ul>
			<li>Local variables are declared within a code block:  <code>{ // this is a code block }</code></li>
			<li>Local variabes never have a scope larger than the method or code block they are defined within. 
			Local variables go out-of-scope with their containing block's closing bracket ( <code>}</code> )</li>
			<li>Variables defined in outer-blocks can be reference by contained inner-blocks</li>
			<li>Instance variables are available as soon as they are initialized and last for the full lifetime of its specific class instance.</li>
			<li>Class variables are in-scope as soon as they are declared and last the entire life of the Java program</li>
		</ul>
		<h2>Object Destruction</h2>
		<ul>
			<li>Note that primitive local-variables are allocated to the <i>stack</i>, and removed from the stack when the execution of its containing code-block is completed.</li>
			<li>All Java objects are allocated and stored on the <i>heap</i>, which is free memory allocated for the program.</li>
			<li><i>Garbage collection</i> is the automatic Java process of automatically freeing memory on the heap by deleting objects that 
			are not longer reachable by the program.  The object is what gets garbage-collected, not its reference.</li>
			<li><b>Garbage collection eligibility</b>
				<ul>
					<li>The object's reference variable is allocated on the stack, and once it goes out-of-scope then the object is eligible for garbage collection.</li>
					<li>Eligibility criteria:
						<ol>
							<li>The object no longer has any references pointing to it (unreachable object), 
								or the references themselves are no-longer reachable.</li>
							<li>All references to the object have gone out of scope.</li>
						</ol>
					</li>
					<li>The method <code>System.gc();</code> suggests that garbage collection be run, but is not <i>guaranteed</i> to do anything.</li>
				</ul>
			</li>
		</ul>
	</body>
</html>