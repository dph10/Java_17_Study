<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style/mystyle.css">
</head>
<body>
    <h1>Ch5: Methods</h1>
    <nav class="navbar">
        <a href="../Ch3_Program_Flow_Control/Ch3_Study_Guide.html">&leftarrow; Ch4 Core APIs</a>
        <a href="../MAIN_index.html">Home</a>
        <a href="../Ch6_Class_Design/Ch6_Class_Design.html">Ch6 Class Design &rightarrow;</a>
    </nav>
    <h2 id="method-structure-section">Method Structure</h2>
    <ul>
        <li>Stucture of a method:<br>
            &Tab;<code>access_modifier optional_specifiers return_type method_name(method_parameters) throws ExceptionType {// method body}</code><br>           
        </li>
        <li>Example <i>method declaration:</i><br>
            &Tab;<code>public static final void myMethod(final int param1, double param2) throws InterruptedException {// method body}</code>
            <p class="tableheader">Method Declaration Structure</p>
            <div class="tablecontainer">
                <table>
                    <tr>
                        <th>Element</th> <th>Example</th> <th>Required?</th>
                    </tr>
                    <tr>
                        <td><a href="#access-modifiers-section">Access modifier</a></td> <td><code>public</code></td> 
                        <td>no, but if not provided it defaults to package-access</td>
                    </tr>
                    <tr>
                        <td><a href="#optional-specifier-section">Optional specifier(s)</a></td> <td><code>static, final</code></td> <td>no</td>
                    </tr>
                    <tr>
                        <td><a href="#return-type-section">Return type</a></td> <td><code>void</code></td> <td>yes, but can be <code>void</code></td>
                    </tr>
                    <tr>
                        <td><a href="#method-name-section">Method name</a></td> <td><code>myMethod</code></td> <td>yes</td>
                    </tr>
                    <tr>
                        <td><a href="#parameter-list-section">Parameter list</a></td> <td><code>(final int param1, double param2)</code></td>
                        <td>yes, but can be empty <code>()</code></td>
                    </tr>
                    <tr>
                        <td><a href="#method-signature-section">Method Signature</a></td> <td>myMethod(final int param1, double param2)</td>
                        <td>yes</td>
                    </tr>
                    <tr>
                        <td><a href="#exception-list-section">Exception list</a></td> <td>throws InterruptedException</td> <td>no</td>
                    </tr>
                    <tr>
                        <td><a href="#method-body-section">Method body</a></td> <td>{// method body}</td> <td>yes, except for <code>abstract</code> methods</td>
                    </tr>
                </table>
            </div>
        </li>
        <li id="access-modifiers-section"><b>Access Modifier:</b> determines which classes can access the method
            <ul>
                <li><code><i>private</i></code>: access only from within the same class (and not subclasses).
                Note that inner-nested classes can access private members of the enclosing class, but static-nested classes cannot.</li>
                <li><i>package-access</i>: access from classes in the same package, also
                known as <i>package-private</i>, or <i>default-access</i> as this level of access is the default applied if 
                another access modifier is provided.  No access from subclasses in another package.</li>
                <li><code><i>protected</i></code>: accessible from a classes in the same package or a subclass.  
                Note that if the subclass is in a different package, it can only access its own <code>protected</code> members and those of other
                subclass in its same package, but not the <code>protected</code> members of superclass/subclass <i>instances</i> from a different packages.</li>
                <li><code><i>public</i></code>: can be accessed from anywhere.  Note that if this package is in a module and is not exported,
                other modules will not be able to access it.</li>
            </ul>
        </li>
        <li id="optional-specifier-section"><b>Optional Specifiers:</b> multiple optional specifiers can be added to method declarations
            <ul>
                <li>
                    <code>static</code>: shared member method of the class
                </li>
                <li>
                    <code>abstract</code>: used in abstract classes or interface without a method body and must be overridden
                    by concrete subclasses
                </li>
                <li>
                    <code>final</code>: specifier that the method cannot be overridden by a subclass
                </li>
                <li>
                    <code>default</code>: used in an <code>interface</code> to provide a default implementation for subclasses
                    that implement the interface
                </li>
                <li>
                    <code>synchronized</code>: used with multithreaded code to create a thread-safe method
                </li>
                <li>
                    <code>native</code>: used when interacting with code written in another language, such as c++ or c, 
                    not covered in this study guide
                </li>
                <li>
                    <code>strictfp</code>: used for making floating-point calculations portable, not covered in this study guide
                </li>
            </ul>
        </li>
        <li>Note that while the access-modifier and optional-modifiers can appear in any order amongst themselves, they 
            <i>must all</i> come before the return-type of the method.  Typically it is good practice to provide the access-modifier first,
            followed by any optional-specifiers (required before the return type).
        </li>
        <li>The <i>method signature</i> is composed of the method name and its parameter list</li>
        <pre><code class="codeblock">
public class Example {
    public void func1() {}
    public final void func2() {}
    public static final void func3() {}
    final static public void func4() {}
    public abstract final func5() {} // doesn't compile, abstract and final are not compatible
    public void final func6() {} // doesn't compile, final required to come before void
    public int funct7 {} // doesn't compile, no parameter list
}
        </code></pre>
        <li id="return-type-section">Return type: must appear after any access-modifiers and optional modifiers, and before the 
            method name. The <code>void</code> keyword is used if there is no return value from the method.  Methods with a return value 
            are required to have a return statement (including for all <code>if</code> or <code>switch</code> cases) with variable/value to be returned: <code>return val;</code> 
        </li>
        <li id="method-name-section">
            Method name: required, follows the <a href="../Ch1_Introduction/Ch1_Study_Guide.html#identifier-rules-section">identifier rules</a>
            and must be ordered between the method name and the parameter list.
        </li>
        <li id="parameter-list-section">
            Parameter list: required, but can be empty <code>()</code>.  
            Paramters must be comma-separated, have a specified data type (<code>var</code> is not valid), and may use the optional
            <code>final</code> modifier.
        </li>
        <li id="method-signature-section">
            Method signature: consists of the method name and parameter list and is used by Java to uniquely determine which 
            method is being called. Java uses the parameter <i>types</i> for the signature, not the parameter names.
            <pre><code class="codeblock">
public class ExampleMethods {
    public void myFunc1(String name, int index) {}
    public void myFunc1(String id, int val) {} // does not compile due to non-unique signature

    // the below function also doesn't compile, because
    // the return type is not used to uniquely determine
    // the method signature
    public int myFunc1(String id2, int val2) { return val2; }

    public void myFunct1(int id, int val) {} // compiles    
}
            </code></pre>
        </li>
        <li id="expection-list-section">
            Exception list: optional list of exceptions preceded by the <code>throws</code> keyword 
            that could be thrown by the method, located between
            the parameter list and method body.  Multiple exception types must be comma-separated.
        </li>
        <li id="method-body-section">Method body: the required final part of method declaration which consists of a code block, 
            requires a <code>return</code> statement if the method has a return-type other than <code>void</code>.

        </li>
    </ul>
    <h2 id="method-variables-section">Variables in Methods</h2>
    <ul>
        <li>A method may declare and use local variables, and also access instance and class(<code>static</code>) member variables/fields</li>
        <li>While an object may be returned from a method and accessed by the method's caller, 
            any local reference variables declared within the method are out-of-scope once the method body has executed.</li>
        <li>The only local variable modifier is <code>final</code>, which creates a constant primitive variable or prevents a reference variable
        from pointing to a different object.  They are not required to be initialized unless they are actually used.</li>
        <li>An <i>effectively final</i> variable is assigned a value only once and never changed, independent of whether it
        uses the <code>final</code> modifier.  This includes declaring the variable in on statement, and initializing it (once) in another statement.</li>
        <li id="instace-variable-modifiers">
            <b>Instance Variable Modifiers:</b> 
            <ul>
                <li>
                    Instance variables use the same <a href="#access-modifiers-section">access-modifiers</a> as methods.
                </li>
                <li>
                    Optional specifiers:
                    <ul>
                        <li><code>final</code>: specifies the instance variable must be initialized with each instance of
                        the class exactly once.  This initialization can occur either inline with its declaration, an instance initializer block,
                         or in the class constructor.</li>
                        <li><code>volatile</code>: tells the JVM that this variable may be modified by other threads</li>
                        <li><code>transient</code>: specifies that the instance variable should not be serialized with the class instance</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <h2 id="varargs section">Working with Varargs</h2>
    <ul>
        <li>
            A method may use a Varargs parameter and treat it as an array in the method body
        </li>
        <li>
            Rules:
            <ol>
                <li>A method can have <i>at most one</i> Varargs parameter</li>
                <li>If a method does inclue a Varargs parameter, it must be last in the parameter list</li>
            </ol>
        </li>
        <pre><code class="codeblock">
public class VarargsExample {
    public static void func1(int start, int... vals) { 
        System.out.println(java.util.Arrays.toString(vals));
    }

    public static void func2(int... start, int... vals) {} // does not compile
}
        </code></pre>
        <li>When calling a method with varargs, you can pass in an array as the varargs parameter, or you
            can provide a list of comma-separated values of the corresponding data type.  In the latter, Java
            will automatically provide the method with an array built from your values.  </li>
            <li>You can also pass in zero arguments for the Varargs parameter and an empty list will be 
                provided to the method body.</li>
            <pre><code class="codeblock">
final int[] data = {1,2,3};
func1(0, data); // [1, 2, 3]
func1(0, 4, 5, 6, 10); // [4, 5, 6, 10]
func1(0); // []
            </code></pre>        
        <li>Accessing a Varargs parameter from the method body is equivalent to accessing a 1d-array</li>
    </ul>
    <h2 id="access-modifier-section">Applying Access Modifiers</h2>
    <p class="tableheader">A method in _______ can access a _______ member</p>
    <div class="tablecontainer">
        <table>
            <tr><th></th><th><code>private</code></th> <th>package</th> <th><code>protected</code></th> <th><code>public</code></th></tr>
            <tr><td>the same class</td> <td>Yes</td> <td>Yes</td> <td>Yes</td> <td>Yes</td></tr>
            <tr><td>another class in the same package</td> <td>No</td> <td>Yes</td> <td>Yes</td> <td>Yes</td></tr>
            <tr><td>a sublcass in a different package</td> <td>No</td> <td>No</td> <td>Yes</td> <td>Yes</td></tr>
            <tr><td>unrelated class in a different package</td> <td>No</td> <td>No</td> <td>No</td> <td>No</td></tr>
        </table>
    </div>
    <h2 id="static-section">Accessing <i><code>static</code></i> Data</h2>
    <ul>
        <li>The <code>static</code> keyword designates a member as belonging to the class rather than a single instance of the class</li>
        <li>Can also be used with an <code>import</code> statement to import a <code>static</code> method from a class in a different package</li>
        <li>Static variables and methods are accessed by putting the name before the method or variable: <code>Math.round(doubleVal);</code></li>
        <li>An instance object of the class can also be used to access/call a <code>static</code>method, including a <code>null</code>
        reference variable! </li>
        <li>Note that a <code>static</code> member cannot call an instance member without a reference variable to an instance of the class</li>
        <li><code>static</code> variables can be declared with the same modifiers as <a href="#instace-variable-modifiers">instance variables</a>
            <ul>
                <li>
                <code>static final</code> variables are usually considered constants and use a naming convention of call capital letters with underscores
                between the words: <code>public static final int NUM_BINS = 10;</code>
                </li>
                <li><code>static final</code> variables use <a href="#static-init-section"><i><code>static</code> initializers</i></a> in the class definition</li>
            </ul>
        </li>
        <li id="static-init-section"><b><code>static</code> initializers</b>
            <ul>
                <li>Consists of a <code>static</code> code block and are run when the <code>class</code> is first used and before any <code>class</code> instance constructors: <br><code>static { // init static final variables}</code></li> 
                <pre><code class="codeblock">
public static final int INCHES_TO_CENTIMETER;

static {
    INCHES_TO_CENTIMETER = 2.54;
}
                </code></pre>
                <li>It is generally good practice to only use a <code>static</code> initializer if it takes more than 1 line of code
                to initialize a <code>static final</code> class variable.</li>
            </ul>
        </li>
        <li><code>static</code> Imports: used to import <code>static</code> member of classes, and can be used with wildcards
            <pre><code class="codeblock">
import static java.util.Arrays.*;

public class MainClass {
    public static void main(final String... args) {
        final int[] arr1 = {1, 2, 3};
        final int[] arr2 = {-10, 3, 5};

        final boolean compareArrays = compare(arr1, arr2) &lt; 0; // false
    }
}
            </code></pre>
        </li>
    </ul>
    <h2 id="method-data-section">Passing Data to and from Methods</h2>
    <ul>
        <li>Note that method parameters are <b><i>passed by value</i></b> in Java.  This applies to both primitive values and reference variables.</li>
        <li>Assigning a new primitive/reference value to a method parameter within the method body doesn't change the caller variable</li>
        <li>Calling a method on a mutable object within the method body can make changes that affect the caller.</li>
        <li>Java can automatically convert a primitive to its wrapper object type for method parameters and returning from objects: called <i>Autoboxing</i></li>
        <li>Java can also automatically convert a wrapper object type to its corresponding primitive data type for methods: called <i>Unboxing</i>
            <pre><code class="codeblock">
int counts = 5;
Integer intCount = counter; // Autoboxing
counter = intCount; // Unboxing
            </code></pre>
        </li>
        <li>Note that Java <i>cannot</i> cast to a larger datatype and Autobox at the same time!
<pre><code class="codeblock">
    Long badVal = 8; // does not compile
    Character endChar = null;
    char val = endChar; // runtime exception: NullPointerException
</code></pre>
        </li>
        <li>Java <i>cannot</i> autobox arrays, ex: <code>int[] ints</code> cannot be autoboxed to <code>Integer[] intWraps</code></li>
    </ul>
    <h2 id="overloading-section">Overloading Methods</h2>
    <ul>
        <li><i>Method overloading</i> is used to write multiple methods with the same name, all with 
            different/unique parameter types, yielding unique method signatures.
        </li>
        <li>The return type is not part of the method signature, so only changing the return types is not valid method overloading
        </li>
        <li>Java automatically looks for the matching types in the method signature and calls
            the most specific version (chooses subclasses over superclasses if available)
        </li>
        <p class="tableheader">Java overloading selection order</p>
        <div class="tablecontainer">
            <table>
                <tr><th>Rule</th> <th>Example</th></tr>
                <tr><td>Exact match by type</td> <td><code>String sumVals(int i, int j);</code></td></tr>
                <tr><td>Larger primitive type</td> <td><code>String sumVals(long i, long j);</code></td></tr>
                <tr><td>Autoboxed type</td> <td>String sumVals(Integer i, Integer j);</td></tr>
                <tr><td>Varargs</td><td>String sumVals(int... nums);</td></tr>
            </table>
        </div>
        <pre><code class="codeblock">
public class Test {
    public void print(byte x) {
        System.out.print("byte ");
    }
    public void print(int x) {
        System.out.print("int ");
    }
    public void print(float x) {
        System.out.println("float ");
    }
    public void print(Object x) {
        System.out.println("object ");
    }

    public static void main(String[] args) {
        Test t = new Test();
        short s = 321;

        t.print(s); // int (larger primitive type)
        t.print(true); // object (autoboxing to Boolean)
        t.print(3.14); // object (autoboxing to Double)
    }
}
        </code></pre>
    </ul>
</body>
</html>